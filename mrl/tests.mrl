(defmacro assert-equal
  (n input output)
  `(let (actual-output (js/interpret ~input))
     (if (eq? ~output actual-output)
       (console-log (str "Test " ~n " successful: '" 
                         ~input "' -> '" ~output "'"))
       (console-error (str "Test " ~n " failed: '" ~input "' yields '" 
                           actual-output "' instead of '" ~output "'")))))

(def tests
  '(
    1   'a a
    2   '(a b c) (a b c)
    3   (atom 'a) true
    4   (atom '(a b c)) false
    5   (atom '()) true
    6   (atom (atom 'a)) true
    7   (atom '(atom 'a)) false
    8   (eq? 'a 'a) true
    9   (eq? 'a 'b) false
    10  (eq? '() '()) true
    11  (head '(a b c)) a
    12  (tail '(a b c)) (b c)
    13  (cons 'a '(b c)) (a b c)
    14  (cons 'a (cons 'b (cons 'c '()))) (a b c)
    15  (cons 'a ()) (a)
    16  (cons 'a '()) (a)
    17  (if (eq? 'a 'b) 'first 'second) second
    18  (if (eq? () ()) 'first 'second) first
    19  ((% x . (cons x '(b))) 'a) (a b)
    20  ((% x y . (cons x (tail y))) 'z '(a b c)) (z b c)
    21  ((% f . (f '(b c))) (% x . (cons 'a x))) (a b c)
    22  ((def subst 
           (% x y z . 
              (if (atom z) 
                (if (eq? z y) x z) 
                (cons (subst x y (head z))
                      (subst x y (tail z))))))
           'm 'b '(a b (a b c) d)) (a m (a m c) d)
    23  `() ()
    24  `~() ()
    25  `(cons 'a ()) (cons (quote a) ())
    26  '(cons 'a ()) (cons (quote a) ())
    27  ''(cons 'a ()) (quote (cons (quote a) ()))
    28  `~'a a
    29  `(cons ~(if true 'first 'second) (cons ~(eq? 'a 'b) ())) (cons first (cons false ()))
    30  ((% x y z . (cons y (cons z ()))) (def f (% x . (eq? x 'a))) (f 'a) (f 'b)) (true false)
    31  ((macro (x) `(cons ~x '(Z))) 'U) (U Z)
    32  ((% x y . y) (defmacro mycons (a b) `(cons ~a ~b)) (mycons 'T '(S))) (T S)
    33  ((% x y . y) (defn mycons (a b) (cons a b)) (mycons 'T '(S))) (T S)
    34  ((% x y . y) (defn f (a b & more) (cons a more)) (f 'X 'Y 'W 'O 'W)) (X W O W)
    35  ((% x y . y) (defn f (& opt) (cons 'OPTIONAL-ARGS opt)) (f 'X 'Y 'W 'O 'W)) (OPTIONAL-ARGS X Y W O W)
    36  (eq? (tail '(Z)) ()) true
    37  (reduce (% l e . (cons e l)) () '(A B C)) (C B A)
    38  (map (% v . (eq? v 'X)) '(X Y Z X Q)) (true false false true false)
    39  (.concat "AB" "CD") "\"ABCD\""
    40  "\"test\""  "\"test\""
    41  (cons "hi" (cons "hey" '("hello"))) ("hi" "hey" "hello")
    42  (eq? "test" 'test) false
    43  (str "con" #_ "comment" "ca" "te" "na" "tion") "\"concatenation\""
    44  (eq? "test" "test") true
    45  (apply (% x y z . (cons x (cons y z))) '(a b ())) (a b)
    46  (apply str '(true false "test")) "\"truefalsetest\""
    47  ((% x . ((% y . x))) 'Z) Z
    48  (apply (% x y . x) '(T F)) T
    49  (apply (% x y . y) '(T F)) F
    50  ((% l . (id (head l))) '('A)) (quote A)
    50  (let (x 'A) x) A
    51  (let (x 'A y ()) (cons x y)) (A)
    52  (last '(a b c d e f g)) g
    53  (map str '(% a #_ (gar bage) . (list a v))) "(\"lambda\" \"(a)\" \"(list a v)\")"
    54  (js/stringify '(% a . (list a v))) "\"(lambda (a) (list a v))\""
    55  ((% a-b c-d . (cons a-b c-d)) 'x-y ()) (x-y)
    56  ((% x . x) (def binde-strich 'TEST) binde-strich) TEST
    57  (infix-call "+" 3 4) 7
    58  (infix-call "^" 1 2) 3
    59  (^ 1 2) 3
    60  (+ 111 222) 333
    61  (- 111 222) -111
    62  (* 111 222) 24642
    63  (| 8 1) 9
    64  (^ (^ (^ 23) 66) 23) 66
    65  (list #_ any #_ (garbage) #_ 'will 'be 'ignored) (be ignored)
    66  (take 4 '(a b c d e f g)) (a b c d)
    67  (take 4 '(a b)) (a b)
    68  (drop 4 '(a b c d e f g)) (e f g)
    69  (drop 4 '(a b)) ()
    70  (let (x 'A y x) y) A
    71  (let (x 11 y x f (% x . (* x x)) k (f y)) k) 121
    72  (let (x 'A y '(B)) (cons x y)) (A B)
    73  (let (x 'S) (def y x)) S
    74  '[1 2 3 4] (1 2 3 4)
    75  ((lambda [a b] (+ a b)) 2 3) 5
    75  ((defn f [a b] (* a b)) 2 3) 6

    ))

(defn process-tests (tests)
  (if (empty? tests) ()
    (do (assert-equal (head tests) (second tests) (third tests))
      (process-tests (tail (tail (tail tests)))))))

(defn run-tests ()
  (let (get-time (% . (.getTime (new Date)))
        start (get-time)
        result (process-tests (map str tests))
        end (- (get-time) start)
        result (str "All tests executed in " end "ms."))
    (do
      (console-log result)
      result)))
