; this file contains all core functions of Mineral

; PREPROCESSORS

(def empty? (% coll . (eq coll ())))

(def list (fn [& items] items))


(def backquote-helper
  (% args .
     (if (empty? args) args
       (if (atom args) (list 'quote args)
         (if (eq 'unquote (head args))
           (head (tail args))
           (list
             'cons
             (backquote-helper (head args))
             (backquote-helper (tail args))))))))

(def backquote
  (macro [exp] 
         (list 'backquote-helper (list 'quote exp))))
 
; MACROS

(def defmacro
  (macro
    [name args body]
    `(def ~name
       (macro ~args ~body))))

(def defn
  (macro 
    [name args body]
    `(def ~name
       (fn ~args ~body))))

(defmacro let [args exp]
  (reduce-right
    (% pair memo .
       (list 
         (list 'fn 
               (cons (head pair) ()) 
               memo)
         (second pair)))
    exp
    (partition 2 args)))

; VARIOUS

(defmacro new [object & args]
    `(.eval js/window 
            (str "new " ~(list 'quote object) "()")))

(def id (% x . x))

(defn do [& statements]
  (last statements))

; LISTS CORE

(defn reduce [f memo coll]
  (if (empty? coll)
    memo
    (reduce f
            (f memo (head coll))
            (tail coll))))

(defn reduce-right [f memo coll]
  (if (empty? coll)
    memo
    (f (head coll) (reduce-right f memo (tail coll)))))

(defn map [f coll]
  (if (empty? coll) 
    ()
    (cons
      (f (head coll))
      (map f (tail coll)))))

; LOGIC

(defmacro or [& vals]
  `(reduce (% m e . 
              (if m true e)) 
           false
           ~(cons 'list vals)))

(defmacro and [& vals]
  `(reduce (% m e . 
              (if e m false)) 
           true
           ~(cons 'list vals)))

(defn not [value] (if value false true))

(defn eq-object [a b]
  (if (atom a) (eq a b)
    (and (eq (head a) (head b))
         (eq-object (tail a) (tail b)))))

(defn = [& values]
  (second
    (reduce (% m e .
               (list e 
                     (and (second m) (eq-object e (head m)))))
            (list (head values) true) (tail values))))


; STRINGS

(defn str [& strings]
  (reduce-right 
    (% elem memo . (.concat (js/stringify elem) memo))
    ""
    strings))

(defn console-log [string]
  (.log js/console string))

(defn console-error [string]
  (.error js/console string))

(defn substr [string start end]
  (.slice string start end))

; ARITHMETIC

(map (% x . (js/interpret
              (js/stringify 
                `(defn ~x (a b) (infixcall '~x a b))))) '(+ - * / < > >= <= ^ & |))

; LISTS BONUS

(defn reverse [coll]
  (reduce (% memo elem . (cons elem memo)) () coll))

(defn push [elem coll]
  ((% coll .
      ((% x . coll) (.push coll elem)))
      (.slice coll 0)))

; TODO: tail recursion!
(defn range [n]
  (if (= n 0) '(0)
    (push n (range (- n 1)))))

(defn slice-into [acc coll n]
  (if (or (= n 0) (empty? coll)) (list acc coll)
    (slice-into (push (head coll) acc) (tail coll) (- n 1))))

(defn take [n coll]
  (head (slice-into () coll n)))

(defn drop [n coll]
  (second (slice-into () coll n)))

(defn partition [n coll]
  (if (empty? coll)
    ()
    ((% pair .
        (cons (head pair)
              (partition n (second pair))))
        (slice-into () coll n))))

(defn second [coll] (head (tail coll)))

(defn third [coll] (head (tail (tail coll))))

(defn last [coll]
  (let [elem (head coll)
        rest (tail coll)]
    (if (empty? rest) elem (last rest))))

(defn nth [coll n]
  (if (< n 1)
    (if (not (empty? coll)) (head coll))
    (nth (tail coll) (- n 1))))

; TODO: tail recursion!
(defn count [coll]
  (if (empty? coll) 0 (+ 1 (count (tail coll)))))

; ALIASES

(defn ! [& strings]
  (console-log (apply str strings)))
