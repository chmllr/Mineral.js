; this file contains all core functions of Mineral

; PREPROCESSORS

(def list (fn [& items] items))

(def backquote-helper
  (% args .
     (if args
       (if (atom args) (list 'quote args)
         (if (eq 'unquote (head args))
           (head (tail args))
           (list
             'cons
             (backquote-helper (head args))
             (backquote-helper (tail args)))))
       args)))

(def backquote
  (macro [exp] 
         (list 'backquote-helper (list 'quote exp))))
 
; MACROS

(def defmacro
  (macro
    [name args body]
    `(def ~name
       (macro ~args ~body))))

(def defn
  (macro 
    [name & variations]
    `((% y x . x)
      (def ~name (fn @variations))
      (assoc ~name 'META {'doc ""
                          'source '(defn ~name @variations)}))))

(defmacro let [args exp]
  (reduce-right
    (% pair memo .
       (list 
         (list 'fn 
               (cons (head pair) ()) 
               memo)
         (second pair)))
    exp
    (partition 2 args)))

; LISTS CORE

(defn reduce [f memo coll]
  (if coll
    (reduce f
            (f memo (head coll))
            (tail coll))
    memo))

(defn reduce-right [f memo coll]
  (if coll (f (head coll) (reduce-right f memo (tail coll))) memo))

(defn map [f coll]
  (if coll
    (cons
      (f (head coll))
      (map f (tail coll)))
    ()))

; LOGIC

(defmacro or [& vals]
  `(reduce (% m e . 
              (if m true e))
           false
           ~(cons 'list vals)))

(defmacro and [& vals]
  `(reduce (% m e .
              (if e m false))
           true
           ~(cons 'list vals)))

(defn not [value] (if value false true))

(defn eq-object [a b]
  (if (atom a) (eq a b)
    (and (eq (head a) (head b))
         (eq-object (tail a) (tail b)))))

(defn = [& values]
  (second
    (reduce (% m e .
               (list e 
                     (and (second m) (eq-object e (head m)))))
            (list (head values) true) (tail values))))

; STRINGS

(defn str-primitive [arg]
  (if (js/isString arg) arg (js/stringify arg)))

(defn str [& strings]
  (.join (map str-primitive strings) ""))

(defn console-log [string]
  (.log js/console string))

(defn console-error [string]
  (.error js/console string))

(defn substr [string start end]
  (.slice string start end))

; ARITHMETIC & BIT OPERATIONS

(map (% x . (js/interpret (str `(defn ~x (a b) (infixcall '~x a b)))))
     '(+ - * / < > >= <= ^ & | %))

; LISTS BONUS

(defn reverse [coll] (.reverse coll))

(defn sort [coll] (.sort coll))

(defn concat [a b] (.concat a b))

(defn push [elem coll]
  ((% coll .
      ((% x . coll) (.push coll elem)))
      (.slice coll 0)))

(defn pop [coll]
  ((% coll .
      ((% x . coll) (.pop coll)))
      (.slice coll 0)))

(defn range
  ([n] (range () n))
  ([acc n]
    (do (.unshift acc n)
      (if (eq n 0) acc
        (range acc (- n 1))))))

(defn split-at [coll n]
  (list (.slice coll 0 n) (.slice coll n)))

(defn take [n coll] (.slice coll 0 n))

(defn drop [n coll] (.slice coll n))

(defn partition [n coll]
  (if coll
    ((% pair .
        (cons (head pair)
              (partition n (second pair))))
        (split-at coll n))
    ()))

(defn second [coll] (nth coll 1))

(defn third [coll] (nth coll 2))

(defn count [coll] (.length coll))

(defn nth [coll n]
  (if (<= 0 n)
    (get coll n)
    (get coll (+ (count coll) n))))

(defn filter [p? coll]
  (if coll
    (let [e (head coll)
          r (filter p? (tail coll))]
      (if (p? e) (cons e r) r))
    ()))

(defn index-of [coll elem]
  ; TODO: for non-primitive type use filter with '='
  (.indexOf coll elem))

(defn last [coll] (nth coll -1))

; VARIOUS

(defmacro new [object & args]
    `(.eval js/window 
            (str "new " ~(list 'quote object) "()")))

(defn id [x] x)

(defn empty? [coll] (eq coll ()))

(defn do [& statements]
  (last statements))

(defmacro timer [exp]
  `(let [get-time (% . (.getTime (new Date)))
         start (get-time)
         result ~exp
         time (- (get-time) start)]
     {'RESULT result 'TIME (str time "ms")}))

(defn meta [o] (get o 'META))

(defn source [f] (get (meta f) 'source))

(defn doc [f] (get (meta f) 'doc))

; MAPS

(defn keys [o] (.keys js/Object o))

(defn clone-object [o]
  (if (js/isList o)
    (map clone-object o)
    (if (js/isObject o)
      (reduce (% m k . (assoc m k (clone-object (get o k)))) {} (keys o))
      o)))

(defn set [m k v]
  (assoc (clone-object m) k v))

(defn remove [m k]
  (dissoc (clone-object m) k))

; ALIASES

(defn ! [& strings]
  (console-log (apply str strings)))
