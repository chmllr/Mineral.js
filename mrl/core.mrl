; this file contains all core functions of Mineral

; PREPROCESSORS

(def empty? (% coll . (eq coll ())))

(def list (fn [& items] items))


(def backquote-helper
  (% args .
     (if (empty? args) args
       (if (atom args) (list 'quote args)
         (if (eq 'unquote (head args))
           (head (tail args))
           (list
             'cons
             (backquote-helper (head args))
             (backquote-helper (tail args))))))))

(def backquote
  (macro [exp] 
         (list 'backquote-helper (list 'quote exp))))
 
; MACROS

(def defmacro
  (macro
    [name args body]
    `(def ~name
       (macro ~args ~body))))

(def defn
  (macro 
    [name args body]
    `(def ~name
       (fn ~args ~body))))

(defmacro let [args exp]
  (reduce-right
    (% pair memo .
       (list 
         (list 'fn 
               (cons (head pair) ()) 
               memo)
         (second pair)))
    exp
    (partition 2 args)))

; VARIOUS

(defmacro new [object & args]
    `(.eval js/window 
            (str "new " ~(list 'quote object) "()")))

(def id (% x . x))

(defn do [& statements]
  (last statements))

; LISTS CORE

(defn reduce [f memo coll]
  (if (empty? coll)
    memo
    (reduce f
            (f memo (head coll))
            (tail coll))))

(defn reduce-right [f memo coll]
  (if (empty? coll)
    memo
    (f (head coll) (reduce-right f memo (tail coll)))))

(defn map [f coll]
  (if (empty? coll) 
    ()
    (cons
      (f (head coll))
      (map f (tail coll)))))

; LOGIC

(defmacro or [& vals]
  `(reduce (% m e . 
              (if m true e))
           false
           ~(cons 'list vals)))

(defmacro and [& vals]
  `(reduce (% m e .
              (if e m false))
           true
           ~(cons 'list vals)))

(defn not [value] (if value false true))

(defn eq-object [a b]
  (if (atom a) (eq a b)
    (and (eq (head a) (head b))
         (eq-object (tail a) (tail b)))))

(defn = [& values]
  (second
    (reduce (% m e .
               (list e 
                     (and (second m) (eq-object e (head m)))))
            (list (head values) true) (tail values))))

; STRINGS

(defn str-primitive [arg]
  (if (js/isString arg) arg (js/stringify arg)))

(defn str [& strings]
  (.join (map str-primitive strings) ""))

(defn console-log [string]
  (.log js/console string))

(defn console-error [string]
  (.error js/console string))

(defn substr [string start end]
  (.slice string start end))

; ARITHMETIC

(map (% x . (js/interpret
              (js/stringify 
                `(defn ~x (a b) (infixcall '~x a b)))))
     '(+ - * / < > >= <= ^ & |))

; LISTS BONUS

(defn reverse [coll]
  (reduce (% memo elem . (cons elem memo)) () coll))

(defn push [elem coll]
  ((% coll .
      ((% x . coll) (.push coll elem)))
      (.slice coll 0)))

(defn range-helper [acc n]
  (do (.unshift acc n)
    (if (eq n 0) acc
      (range-helper acc (- n 1)))))

(defn range [n]
  (range-helper () n))

(defn split-at [coll n]
  (list (.slice coll 0 n) (.slice coll n)))

(defn take [n coll]
  (head (split-at coll n)))

(defn drop [n coll]
  (second (split-at coll n)))

(defn partition [n coll]
  (if (empty? coll)
    ()
    ((% pair .
        (cons (head pair)
              (partition n (second pair))))
        (split-at coll n))))

(defn second [coll] (nth coll 1))

(defn third [coll] (nth coll 2))

(defn count [coll] (.length coll))

(defn nth [coll n]
  (if (<= 0 n)
    (get coll n)
    (get coll (+ (count coll) n))))

(defn last [coll] (nth coll -1))

; ALIASES

(defn ! [& strings]
  (console-log (apply str strings)))
