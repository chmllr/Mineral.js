; this file contains all core functions of Mineral

; PREPROCESSORS

(def empty? (% coll . (eq? coll ())))

(def list (fn (& items) items))


(def backquote-helper
  (% args .
     (if (empty? args) args
       (if (atom? args) (list 'quote args)
         (if (eq? 'unquote (head args))
           (head (tail args))
           (list
             'cons
             (backquote-helper (head args))
             (backquote-helper (tail args))))))))

(def backquote (macro (exp) (list 'backquote-helper (list 'quote exp))))
 
; MACROS

(def defmacro
  (macro
    (name args body)
    `(def ~name
       (macro ~args ~body))))

(def defn
  (macro 
    (name args body)
    `(def ~name
       (fn ~args ~body))))

(defmacro let
  (args exp)
  (reduce
    (% memo pair .
       (list 
         (list 'fn 
               (cons (head pair) ()) 
               memo)
         (second pair)))
    exp
    (reverse (partition 2 args))))

; VARIOUS

(defmacro new (object & args)
  `(.eval js/window (str "new " ~(list 'quote object) "()")))

(defn infix-call (op a b)
  (.eval js/window (str a op b)))

(def id (% x . x))

(defn do
  (& statements)
  (last statements))

(defmacro or (a b)
  `(if ~a true ~b))

(defmacro and (a b)
  `(if ~a ~b false))

; LISTS CORE

(defn
  reduce (f memo coll)
  (if (empty? coll)
    memo
    (reduce f
            (f memo (head coll))
            (tail coll))))

(defn reduce-right (f memo coll)
  (if (empty? coll)
    memo
    (f (head coll) (reduce-right f memo (tail coll)))))

(defn map (f coll)
  (if (empty? coll) 
    ()
    (cons
      (f (head coll))
      (map f (tail coll)))))

(defn
  reverse (coll)
  (reduce (% memo elem . (cons elem memo)) () coll))

; STRINGS

(defn str (& strings)
  (reduce-right 
    (% elem memo . (.concat (js/stringify elem) memo))
    ""
    strings))

(defn console-log (string)
  (.log js/console string))

(defn console-error (string)
  (.error js/console string))

; ARITHMETIC

(map (% x . (js/interpret
              (js/stringify 
                `(defn ~x (a b) (infix-call (str (quote ~x)) a b))))) '(+ - * / ^ & |))

; LISTS BONUS

(defn take (n coll)
  (if (or (eq? n 0) (empty? coll))
    ()
    (cons (head coll)
      (take (- n 1) (tail coll)))))

(defn drop (n coll)
  (if (or (eq? n 0) (empty? coll))
    coll 
    (drop (- n 1) (tail coll))))

(defn partition (n coll)
  (if (empty? coll)
    ()
    (cons (take n coll)
          (partition n (drop n coll)))))

(defn second (coll) (head (tail coll)))

(defn third (coll) (head (tail (tail coll))))

(defn last (l)
  (let (elem (head l)
             rest (tail l))
    (if (empty? rest) elem (last rest))))

